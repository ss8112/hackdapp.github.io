<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HackDApp</title>
  
  <subtitle>专注于DApp教程、思维成长、Mac技巧的IndieMaker</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.hackdapp.com/"/>
  <updated>2019-03-25T02:02:39.999Z</updated>
  <id>https://www.hackdapp.com/</id>
  
  <author>
    <name>zhangliang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习周报-13W: 六经注我</title>
    <link href="https://www.hackdapp.com/archives/weekly13.html"/>
    <id>https://www.hackdapp.com/archives/weekly13.html</id>
    <published>2019-03-24T16:00:00.000Z</published>
    <updated>2019-03-25T02:02:39.999Z</updated>
    
    <summary type="html">
    
      本周最大的收获就是：
    
    </summary>
    
      <category term="周报(2019)" scheme="https://www.hackdapp.com/categories/%E5%91%A8%E6%8A%A5-2019/"/>
    
    
      <category term="学习周报" scheme="https://www.hackdapp.com/tags/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>学习周报-12W: 持续的精力投入并以文字记录成长</title>
    <link href="https://www.hackdapp.com/archives/weekly12.html"/>
    <id>https://www.hackdapp.com/archives/weekly12.html</id>
    <published>2019-03-18T13:07:52.000Z</published>
    <updated>2019-03-18T14:14:59.165Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你的目标是什么？给自己一个deadline？</p></blockquote><p><strong>说给自己听的</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">有时候感觉和自己对话<span class="comment">(不是自主自语啊，其实就是写字的过程，将自己的想法写成文字)</span>的状态真的很棒，</span><br><span class="line">在写的过程慢慢能够唤醒心中的另一个声音，通过这种方式要可以让自己心放松下来，降低心中的焦虑，取而代之的是具体的行事方式。</span><br><span class="line">比如：今天上午的状态就不是太好，自己的调解方式就是好好洗把脸、清醒清醒。想想内心愉悦的事。</span><br><span class="line">用成就的事情来消除头脑的焦虑。要明白焦虑不是一种对抗状态，不是解决方式。要直面问题，而非情绪，不由得又想起黄执中老师对于情绪管理的一些理解。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对自己最大的动力便是，通过文字记录自己的成长。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">要给自己一个期限，不可能一直按现有薪资做某一项事情，你当初的目的就是跨界成长。如果由于自己的惰性而放松的化，那还不如回到当初的状态，最起码薪资要比现在的高出不少。不正视自己的努力与蜕变，那就是对自己的不尊重。</span><br></pre></td></tr></table></figure><hr><h2 id="见"><a href="#见" class="headerlink" title="见"></a>见</h2><h3 id="2019-03-18"><a href="#2019-03-18" class="headerlink" title="2019-03-18"></a>2019-03-18</h3><ol><li>雇佣是存量思维，投资自己是增量思维<br> 这个是在spenser文章看到的一句话。看待事物不能只看于其表面所带来的价址，而应该往其未来价值或更深层次的价值。比如：是否在课程或某项活动存在一些高质量潜在的用户。</li><li>Achieve3000<br> 偶尔看到一个关于Lexile值，即蓝思值的测试了解到的。也搜到了一些根据蓝思值推荐书籍的网站</li><li><a href="https://www.lyric.im/maker-vs-manager" target="_blank" rel="noopener">译：创造者 vs 管理者，日程规划能成就了你的工作，也可能毁掉你的工作 - GitPress.io</a><br> 这篇文章之所以看到，是因为作者设计了一款关于微信公众号排版工具，从他所关联的网站所了解到的。</li><li><a href="https://www.lyric.im/how-to-improve-english-reading-level-from-870L-to-1300L" target="_blank" rel="noopener">我如何在两个月内把英语阅读水平从六年级提高大学 - GitPress.io</a></li><li>ReadingPro<br> <a href="http://www.readingpro.cn/，这个网站可以进行蓝思值的测试，不过需要支付50元" target="_blank" rel="noopener">http://www.readingpro.cn/，这个网站可以进行蓝思值的测试，不过需要支付50元</a></li><li><a href="http://www.360doc.com/content/18/1127/08/57517105_797492881.shtml" target="_blank" rel="noopener">Achieve3000产品介绍和操作演示</a></li><li><a href="http://www.theprincetonschool.com/lexile-measure#achieve3000" target="_blank" rel="noopener">The Princeton School</a><br> <img src="http://cdn.hackdapp.com/2019-03-18-132706.png" alt=""><br> <a href="http://www.theprincetonschool.com/lexile-measure#achieve3000" target="_blank" rel="noopener">http://www.theprincetonschool.com/lexile-measure#achieve3000</a></li></ol><h2 id="感"><a href="#感" class="headerlink" title="感"></a>感</h2><h3 id="2019-03-18-1"><a href="#2019-03-18-1" class="headerlink" title="2019-03-18"></a>2019-03-18</h3><p>做事情不够专注与投注。 不知道自己在拖什么呢。最直观的感受就是越拖内心压力其实越大。</p><h2 id="思"><a href="#思" class="headerlink" title="思"></a>思</h2><h3 id="2019-03-18-如何能写出一篇让用户特别满意的教程文档"><a href="#2019-03-18-如何能写出一篇让用户特别满意的教程文档" class="headerlink" title="2019-03-18 如何能写出一篇让用户特别满意的教程文档"></a>2019-03-18 如何能写出一篇让用户特别满意的教程文档</h3><p>思考：授之于鱼还是渔<br>思考：用户最喜欢的技术教程是什么样子的。教程结构清晰， 一眼知道需要分几步操作。既要讲的简单，也要讲的深入。讲的简单，其实就是按用户的层次能够提供相应可理解的示例。举例子确实是一个好的方式。最好是使用商业真实场景，demo形式的可能不具代表性。</p><p>就比如写EOS合约文档，就想成把合约里所有的知识都讲出来。但这样写出来的文档，虽然够全，但用户可能因为篇幅太长，而选择性不看。又或者文章内容太长，结构层次反而会有所影响。所以我自己想过之后，是否可以先写一个大纲的形式。然后再从不小章节进行拆分，进行中高阶不同层次的文章讲解来深入理解其技术。<br>EOS智能合约讲解</p><ol><li>简单示例合约，虽然简单但五脏俱全。</li><li>分拆：合约结构设计：字典文件、工具文件、配置文件、接口文件、接口实现。</li><li>分拆：知识点：ABI</li><li>分拆：知识点：数据结构定义。数据类型有哪些，如何进行选择，比如资金字段</li><li>分拆：知识点：如何实现单例存储</li><li>分拆：知识点：multi_index,如何定义二级索引， 索引的多种遍历方式</li><li>分拆: ……</li></ol><h2 id="行"><a href="#行" class="headerlink" title="行"></a>行</h2><h3 id="2019-03-18-2"><a href="#2019-03-18-2" class="headerlink" title="2019-03-18"></a>2019-03-18</h3><p>通过本周所吸收的一些新的信息，觉得可以做且持续可以做的事：</p><ul><li>英语学习<br>增强英语阅读，可以试着通过翻译文章来提高。</li><li>看书<br>不要觉得在客厅看会电视没啥，没啥没啥一二小时过去了。这一天也就过去了。</li><li>持续的技术投入</li></ul><p>需要对时间时刻保持感知， 一分钟、一小时。定好时间规划，该做啥就做啥，在规划中应对风险。</p><hr><p>与其周末花一段时间来总结本周心得，何不每天写一点，这样还可以总结所需消耗的时间。用这部分时间来直接回顾一周文字。</p>]]></content>
    
    <summary type="html">
    
      本周最大的收获就是：运用增量思维的方式去考问题。另外，持续的精力投注，时刻让自己从内心感受到一些成长的感觉。时刻将自己那时那刻的最棒的感觉记录下来，形成文字，当自己不爽的时候，翻出来看看。
    
    </summary>
    
      <category term="周报(2019)" scheme="https://www.hackdapp.com/categories/%E5%91%A8%E6%8A%A5-2019/"/>
    
    
      <category term="学习周报" scheme="https://www.hackdapp.com/tags/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>巧用HistoryApiAction实现对链数据的存储与查询</title>
    <link href="https://www.hackdapp.com/archives/eosdev_datastorage_historyaction.html"/>
    <id>https://www.hackdapp.com/archives/eosdev_datastorage_historyaction.html</id>
    <published>2019-03-13T08:36:13.000Z</published>
    <updated>2019-03-14T06:15:08.440Z</updated>
    
    <content type="html"><![CDATA[<p>在开发EOS DApp智能合约时，我们都知道可以使用<code>multi_index</code>来对合约数据的存储与查询，但合约的存储是需要消耗一定的资源的，而且随着用户的增长往往会导业务数据会越来越大，从而导致合约需要更多的资源来支撑其数据。</p><p>有时我们可以通过业务设计，让业务数据得到即时清理及资源释放。但大多数情况下，业务数据是不允许清理的，那么针对这种情况是否有其他办法来降低对合约存储资源的消耗呢？</p><p>那么，今天分享的方案就是：借用EOS链提供的<code>history_api_action</code>插件服务、内部合约Action调用来完成对业务数据的存储与查询。</p><p>举个🌰️：<br>在去中心化交易所中，往往搓合成功会产生大量的成交订单，那保存在合约数据库中肯定是不合适的，所以可以在搓合方法中通过调用内部日志方法的形式，通过交易日志来将订单数据写入区块中；然后通过EOS节点提供的<a href="https://developers.eos.io/eosio-nodeos/v1.4.0/reference#get_actions-1" target="_blank" rel="noopener">查询历史action接口</a>，查询合约日志数据并增量同步到中心化数据库。</p><p>下面，我们将通过具体的代码示例来帮助大家理解整个过程：</p><hr><p><strong>首先</strong>，我们新创建一个合约(dexchange.hpp/dexchange.cpp)；<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//dexchange.hpp</span><br><span class="line"><span class="comment">#include &lt;eosiolib/eosio.hpp&gt;</span></span><br><span class="line"><span class="comment">#include &lt;eosiolib/print.hpp&gt;</span></span><br><span class="line"></span><br><span class="line">using namespace eosio;</span><br><span class="line"></span><br><span class="line">CONTRACT dexchange : public contract &#123;</span><br><span class="line">  public:</span><br><span class="line">    using contract::contract;</span><br><span class="line">    dexchange(eosio::name receiver, eosio::name code, datastream&lt;const char*&gt; ds):contract(receiver, code, ds) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    [[eosio::action]]</span><br><span class="line">    void executetrade(uint64_t pair_id, uint64_t sell_order_id, uint64_t buy_order_id);</span><br><span class="line"></span><br><span class="line">    [[eosio::action]]</span><br><span class="line">    void <span class="built_in">log</span>(uint64_t deal_price, uint64_t quantity, uint64_t sell_order_id, uint64_t buy_order_id);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EOSIO_DISPATCH(dexchange, (executetrade)(<span class="built_in">log</span>))</span><br><span class="line"></span><br><span class="line">//https://gist.github.com/2b68242019242bdd12f174208e39e7d2</span><br></pre></td></tr></table></figure></p><p><strong>然后</strong>，定义并实现两个方法：executetrade、log。 <code>executetrade</code>合约方法负责搓合业务，当搓合业务处理完之后调用<code>log</code>方法，通过交易信息将参数调用数据写入区块中；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//filename: dexchange.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment">#include "dexchange.hpp"</span></span><br><span class="line"></span><br><span class="line">void dexchange::executetrade(uint64_t pair_id, uint64_t sell_order_id, uint64_t buy_order_id)&#123;</span><br><span class="line">  uint64_t deal_price = 1200;</span><br><span class="line">  uint64_t quantity = 10000;</span><br><span class="line"></span><br><span class="line">  action(</span><br><span class="line">      permission_level&#123; _self, <span class="string">"active"</span>_n &#125;,</span><br><span class="line">      _self, <span class="string">"log"</span>_n,</span><br><span class="line">      std::make_tuple(deal_price, pair_id, sell_order_id, buy_order_id)</span><br><span class="line">  ).send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void dexchange::<span class="built_in">log</span>(uint64_t deal_price, uint64_t quantity, uint64_t sell_order_id, uint64_t buy_order_id)&#123;</span><br><span class="line">  require_auth( _self );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//https://gist.github.com/ea6ec431a57faee3a2823cfeee406efd</span><br></pre></td></tr></table></figure><p>从以上示例可以看出，合约log日志方法其实并不需要做任何业务逻辑处理。只需要间接被调用，便可将我们需要的业务数据通过交易的形式记录在区块中，而不会浪费我们的合约存储空间，也不需要担心资源释放的问题。</p><p><strong>下一步</strong>、发布智能合约，并调用一次<code>executetrade</code>合约方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//发布合约至hackdappexch合约帐户</span><br><span class="line">&gt; cleos <span class="built_in">set</span> contract hackdappexch contracts/ -p  hackdappexch@active</span><br><span class="line"></span><br><span class="line">//执行合约方法</span><br><span class="line">&gt; cleos push action hackdappexch executetrade <span class="string">'[1,2,3]'</span> -p hackdappexch@active</span><br></pre></td></tr></table></figure><p><strong>最后</strong>，通过EOS链节点提供的<a href="https://developers.eos.io/eosio-nodeos/v1.4.0/reference#get_actions-1" target="_blank" rel="noopener">RPC服务</a>，进行历史action数据查询，通过数据过滤找到我们的日志方法及参数数据。</p><p>在确保之前的操作都成功之后，我们使用curl命令查询其对应服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl --request POST \</span><br><span class="line">  --url https://localhost:8888/v1/<span class="built_in">history</span>/get_actions \</span><br><span class="line">  --header <span class="string">'content-type: application/x-www-form-urlencoded; charset=UTF-8'</span> \</span><br><span class="line">  --data <span class="string">'&#123;"pos":-1,"offset":-10,"account_name":"hackdappexch"&#125;'</span></span><br></pre></td></tr></table></figure><p>通过此接口查询出来的数据不仅仅是<code>log</code>合约方法数据，可能还会存在该合约的其他方法事件，需要根据情况再过滤一次数据。</p><p><img src="http://cdn.hackdapp.com/2019-03-13-080641.jpg" alt=""></p><p><strong>补充说明</strong></p><p>如果你在本地曾经搭建过EOS私链的化，那么或许看到过，EOS启动时是可以配置不同插件。而其中有一个插件<code>history_api_plugin</code>，就是用于监听并存储合约方法的调用信息；另外启动链节点时，是可以按规划自由指定所要监听的合约帐户及方法，如： <code>--filter-on hackdappexch::log</code>, 该参数配置表示只监听hackdappexch合约中的log方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nodeos -e -p eosio -d /mnt/dev/data \</span><br><span class="line">  --config-dir /mnt/dev/config \</span><br><span class="line">  --http-validate-host=<span class="literal">false</span> \</span><br><span class="line">  --plugin eosio::producer_plugin \</span><br><span class="line">  --plugin eosio::chain_api_plugin \</span><br><span class="line">  --plugin eosio::http_plugin \</span><br><span class="line">  --plugin eosio::history_api_plugin \</span><br><span class="line">  --http-server-address=0.0.0.0:8888 \</span><br><span class="line">  --access-control-allow-origin=* \</span><br><span class="line">  --contracts-console \</span><br><span class="line">  --filter-on hackdappexch:<span class="built_in">log</span>: \</span><br><span class="line">  --max-transaction-time=1000 \</span><br><span class="line">  --verbose-http-errors &amp;</span><br></pre></td></tr></table></figure><p>如以上EOS节点启动命令，就展示了启动一个EOS节点的具体参数配置。其中，<code>--filter-on</code>参数便是指定只监听记录<code>hackdappexch</code>合约的<code>log</code>方法调用数据。</p><p>所以，当我们要通过链节点RPC服务查询合约方法历史调用数据时，需要先确认提供RPC服务的节点是否开启了<code>history_api_plugin</code>插件，以及自己所要查询的合约是否在其过滤规则之中。</p><hr><p><strong>小结</strong></p><p>通过本篇文章，我们学会了利用<strong>内部合约方法调用</strong> ➕️ <strong>链节点历史Action查询</strong>的方式实现业务数据的另一种数据存储与查询方案。</p><hr><blockquote><p>在教程中如出现错误🐛或不易理解的知识点，欢迎加我微信指正!<br>Name: zhangliang | WeChat: rushking2009 | Mail: <a href="mailto:zhangliang@cldy.org" target="_blank" rel="noopener">zhangliang@cldy.org</a></p></blockquote><p><img class="nofancybox" src="http://cdn.hackdapp.com/2019-03-11-IMG_1625.JPG-blog" style="display: inline;"><img class="nofancybox" src="http://cdn.hackdapp.com/2019-03-11-IMG_1626.jpg-blog" style="display: inline; "></p><hr><h3 id="changelog"><a href="#changelog" class="headerlink" title="changelog"></a><strong>changelog</strong></h3><p>2019-03-13 <a href="mailto:zhangliang@cldy.org" target="_blank" rel="noopener">zhangliang</a></p><ul><li>初次发稿</li></ul>]]></content>
    
    <summary type="html">
    
      在开发EOS DApp智能合约时，我们都知道可以使用`multi\\_index\_`来对合约数据的存储与查询，但合约的存储是需要消耗一定的资源的，而且随着用户的增长往往会导业务数据会越来越大，从而导致合约需要更多的资源来支撑其数据增长。那么是否有一种更好的方式来降低某些场景的资源消耗呢？那么，今天将为你分享一种数据存储方案： 借用EOS链提供的`history_api_action\_`插件、`内部合约Action调用`来完成对业务数据的存储与查询。HackDApp愿与你分享！
    
    </summary>
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/categories/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/tags/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
      <category term="合约数据存储" scheme="https://www.hackdapp.com/tags/%E5%90%88%E7%BA%A6%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
      <category term="history action" scheme="https://www.hackdapp.com/tags/history-action/"/>
    
      <category term="inline action" scheme="https://www.hackdapp.com/tags/inline-action/"/>
    
  </entry>
  
  <entry>
    <title>使用EOS.js发布EOS智能合约</title>
    <link href="https://www.hackdapp.com/archives/eosdev_deploycontract_eosjs.html"/>
    <id>https://www.hackdapp.com/archives/eosdev_deploycontract_eosjs.html</id>
    <published>2019-03-12T10:59:46.000Z</published>
    <updated>2019-03-14T01:23:36.811Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的EOS合约开发文章，你可能学会了如何通过EOS系统命令<strong>cleos set contract</strong>的方式进行智能合约的发布与升级。</p><p>但在开发过程中，可能有的同学持续在命令容器与开发IDE间频繁切换，对开发效率有一定程序的影响，那是否有一种更好的方式帮助我们在一个窗口里快速发布合约呢？</p><p>那么本文将带你了解<strong>如何通过EOS.js进行智能合约的发布</strong>。</p><p><img src="http://cdn.hackdapp.com/2019-03-12-083806.jpg" alt=""><br>如上图所示，在进行合约发布时，需要用到eos系统合约中的两个方法：setcode、setabi。而这两个方法分别会用到智能合约编译后的两个文件： *.wasm、*.abi。</p><p><strong>注意</strong> ： 本文示例中使用的eosjs的版本为<code>16.0.9</code>。</p><p><strong>首先</strong>，需要初始化EOS-SDK实例。 事先准备好初始化SDK所必需的参数：</p><ul><li>chainid<br>  所要发布的目标EOS链chainid. 例如：正式chainid: aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906; jungle测试网chainid: e70aaab8997e1dfce58fbfac80cbbb8fecec7b99cf982a9444273cbc64c41473等等</li><li>httpEndpoint<br>  EOS链环境http接口地址。 例如: <a href="http://localhost:8888" target="_blank" rel="noopener">http://localhost:8888</a></li><li>keyProvider<br>  合约帐户私钥，主要用于交易签名。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//config.js</span><br><span class="line">const Eos = require(<span class="string">'eosjs'</span>)</span><br><span class="line"></span><br><span class="line">const eos = Eos(&#123;</span><br><span class="line">    chainId: <span class="string">"cf057bbfb72640471fd910bcb67639c22df9f92470936cddc1ade0e2f2e7dc4f"</span>,</span><br><span class="line">    httpEndpoint: <span class="string">"http://localhost:8888"</span>,</span><br><span class="line">    keyProvider: <span class="string">"5K7mtrinTFrVTduSxizUc5hjXJEtTjVTsqSHeBHes1Viep86FP5"</span>,</span><br><span class="line">    broadcast: <span class="literal">true</span>,</span><br><span class="line">    sign: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    eos,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//https://gist.github.com/hackdapp/2522411b98b1acdadc0d842f712ca6e0</span><br></pre></td></tr></table></figure><p><strong>下一步</strong>，需要代码实现对合约文件夹中的.wasm及.abi文件的读取；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getDeployableFilesFromDir(dir) &#123;</span><br><span class="line">    const dirCont = fs.readdirSync(dir)</span><br><span class="line">    const wasmFileName = dirCont.find(filePath =&gt; filePath.match(/.*\.(wasm)$/gi))</span><br><span class="line">    const abiFileName = dirCont.find(filePath =&gt; filePath.match(/.*\.(abi)$/gi))</span><br><span class="line">    <span class="keyword">if</span> (!wasmFileName) throw new Error(`Cannot find a <span class="string">".wasm file"</span> <span class="keyword">in</span> <span class="variable">$&#123;dir&#125;</span>`)</span><br><span class="line">    <span class="keyword">if</span> (!abiFileName) throw new Error(`Cannot find an <span class="string">".abi file"</span> <span class="keyword">in</span> <span class="variable">$&#123;dir&#125;</span>`)</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        wasmPath: path.join(dir, wasmFileName),</span><br><span class="line">        abiPath: path.join(dir, abiFileName),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//https://gist.github.com/69b29103e5cc114f4478390076d8ad39</span><br></pre></td></tr></table></figure><p><strong>然后</strong>，通过调用eos实例，分别执行系统合约的setcode/setabi方法，从而达到智能合约的发布；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> deployContract(&#123; account, contractDir &#125;) &#123;</span><br><span class="line">  const &#123; wasmPath, abiPath &#125; = getDeployableFilesFromDir(contractDir)</span><br><span class="line"></span><br><span class="line">  const wasm = fs.readFileSync(wasmPath)</span><br><span class="line">  const abi = fs.readFileSync(abiPath)</span><br><span class="line"></span><br><span class="line">  const codePromise = eos.setcode(account, 0, 0, wasm)</span><br><span class="line">  const abiPromise = eos.setabi(account, JSON.parse(abi))</span><br><span class="line">  <span class="built_in">return</span> Promise.all([codePromise, abiPromise])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//https://gist.github.com/69b29103e5cc114f4478390076d8ad39</span><br></pre></td></tr></table></figure><p><strong>最后</strong>，调用deployContract方法，测试合约发布功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">deployContract(&#123; account: <span class="string">"eosio.token"</span>, contractDir: <span class="string">"./contract"</span> &#125;).<span class="keyword">then</span>((result) =&gt; &#123;</span><br><span class="line">    console.log(`Deployment successful`, JSON.stringify(result, null , 4))</span><br><span class="line">&#125;)</span><br><span class="line">.catch(err =&gt; &#123;</span><br><span class="line">    console.error(`Deployment failed`, err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//https://gist.github.com/69b29103e5cc114f4478390076d8ad39</span><br></pre></td></tr></table></figure><hr><p><strong>小结</strong></p><p>通过本文我们学习了如何通过eos实例的setcode/setabi方法将合约编译文件快速发布到指定链环境。</p><p>另外，如果为了提高发布合约效率，我们还可以在package.json中定义发布合约的运行脚本，并配合IDE工具中的快捷键，便可达到开发效率的进一步提升。</p><hr><blockquote><p>在教程中如出现错误🐛或不易理解的知识点，欢迎加我微信指正!<br>Name: zhangliang | WeChat: rushking2009 | Mail: <a href="mailto:zhangliang@cldy.org" target="_blank" rel="noopener">zhangliang@cldy.org</a></p></blockquote><p><img class="nofancybox" src="http://cdn.hackdapp.com/2019-03-11-IMG_1625.JPG-blog" style="display: inline;"><img class="nofancybox" src="http://cdn.hackdapp.com/2019-03-11-IMG_1626.jpg-blog" style="display: inline; "></p><p>注： 有想了解<strong>愿码全思维IT工程师加速器</strong>的朋友，可以扫码加群咨询。</p><hr><h3 id="changelog"><a href="#changelog" class="headerlink" title="changelog"></a><strong>changelog</strong></h3><p>2019-03-12 <a href="mailto:zhangliang@cldy.org" target="_blank" rel="noopener">zhangliang</a></p><ul><li>初次发稿</li></ul>]]></content>
    
    <summary type="html">
    
      之前我们曾经介绍过如何使用EOS的系统命令(cleos set contract)发布智能合约，那么今天将分享另外一种方式：使用eosjs-sdk发布合约。在此基础上，可以通过配置package.json脚本以及IDE快捷链，可以快速提升DApp开发效率。HackDApp愿与你分享！
    
    </summary>
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/categories/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/tags/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
      <category term="EOS合约开发教程" scheme="https://www.hackdapp.com/tags/EOS%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"/>
    
      <category term="deploy contract" scheme="https://www.hackdapp.com/tags/deploy-contract/"/>
    
  </entry>
  
  <entry>
    <title>剖析EOS合约编译ABI文件</title>
    <link href="https://www.hackdapp.com/archives/eosdev_contract_abi.html"/>
    <id>https://www.hackdapp.com/archives/eosdev_contract_abi.html</id>
    <published>2019-03-07T11:33:14.000Z</published>
    <updated>2019-03-14T01:23:31.513Z</updated>
    
    <content type="html"><![CDATA[<p>相信不少开发者朋友在进行EOS合约开发时，都看到发布智能合约时的ABI文件。那ABI文件到底是什么东西？在EOS公链环境中到底发挥怎么样的作用呢以及如何解读ABI文件内容呢？</p><p>那么本章节将带你了解ABI文件与智能合约间的关系以及了解并学会ABI文件的编写。</p><p><strong>ABI</strong>， 简称(Application Binary Interface), 是一个基于JSON语言的接口描述文档，用于描述EOS合约以及如何对合约方法进行调用。如果大家曾经接触过websocket、avro、hession、thrift等这类技术的化，那么是大体逻辑是相向的。比如websocket所提供的wsdl其实也是对websocket本身对外所提供服务的接口描述。</p><p>在EOS合约，ABI文件是由开发组件eosio.cdt工具包中的eosio-cpp命令执行所生成的文件。但在实际开发时，时常会碰到一些情况无法生成ABI文件。因为在合约开发，我们往往会根据业务自定义一些数据结构，或者使用一些第三方方法，而eosio.cdt本身对所有特隆并不是支持的很完善，所以时常导致编译失败，这时就需要我们理解ABI是如何定义智能合约的，以便于我们定制化修改自己的合约描述。</p><p>ABI文件结构是由什么组成的呢？让我们先看一个示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"version"</span>: <span class="string">"eosio::abi/1.0"</span>,</span><br><span class="line">   <span class="string">"types"</span>: [],</span><br><span class="line">   <span class="string">"structs"</span>: [],</span><br><span class="line">   <span class="string">"actions"</span>: [],</span><br><span class="line">   <span class="string">"tables"</span>: [],</span><br><span class="line">   <span class="string">"ricardian_clauses"</span>: [],</span><br><span class="line">   <span class="string">"abi_extensions"</span>: [],</span><br><span class="line">   <span class="string">"___comment"</span> : <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面json示例展示了一个标准智能合约所应具备的完整属性定义。</p><p><strong>数据类型(type)</strong><br>在项目开发过程，有时为了便于代码的理解，我们会将一些通用数据类型或数据结构进行别名定义，用一个在业务场景中更加贴合业务的名称代替。在<code>types</code>数组中便是对这种情况的定义描述。</p><p>比如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"new_type_name"</span>: <span class="string">"age"</span>,</span><br><span class="line">   <span class="string">"type"</span>: <span class="string">"int"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">   <span class="string">"new_type_name"</span>: <span class="string">"name"</span>,</span><br><span class="line">   <span class="string">"type"</span>: <span class="string">"string"</span> //此处user为自定义数据结构</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于合约内嵌类型，是不会在此展示的。诸如： uint64_t、name、asset、symbol等。下图展示了EOS合约所支持的所有内置数据类型<br><img src="http://image.chaindesk.cn/2019-03-07-095044.jpg" alt=""></p><hr><p><strong>结构体(struct)</strong><br>在业务处理逻辑中，为了方便数据的传输与调用，往往我们会对针对业务数据进行建模并以结构体的形式展现。同样，它也需要在ABI文件中进行描述。</p><p>比如: eosio.token合约中的account结构体定义</p><ul><li><p>ABI文件定义</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"account"</span>,</span><br><span class="line">    <span class="string">"base"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="string">"fields"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"balance"</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"asset"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>eosio.token.hpp实现</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct account &#123;</span><br><span class="line">asset    balance;</span><br><span class="line"></span><br><span class="line">uint64_t primary_key()const &#123;</span><br><span class="line"><span class="built_in">return</span> balance.symbol.code().raw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>另外，需要注意的就是除了以上这种结构体定义，其实还存在一种隐性结构体，即：合约方法参数<br>示例：</p><ul><li><p>eosio.token.hpp中transfer方法定义</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void transfer( name    from,</span><br><span class="line">                        name    to,</span><br><span class="line">                        asset   quantity,</span><br><span class="line">                        string  memo );</span><br></pre></td></tr></table></figure></li><li><p>eosin.token合约中transfer方法在ABI文件中定义</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"name"</span>: <span class="string">"transfer"</span>,</span><br><span class="line"><span class="string">"base"</span>: <span class="string">""</span>,</span><br><span class="line"><span class="string">"fields"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"from"</span>,</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"name"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"to"</span>,</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"name"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"quantity"</span>,</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"asset"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"memo"</span>,</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"string"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>可以看出，隐性结构体与前面所定义显性结构体定义是并没有什么不同，只是在智能合约业务逻辑中，我们仅用到显性结构体来存储我们的业务数据进行逻辑判断。</p><hr><p><strong>方法(Action)</strong><br><code>Action</code>数组主要用于描述外部可调用的方法列表以及具体的参数列表。在智能合约中，如果需要对外公开合约方法，往往会在合约头文件中进行如下定义：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[eosio::action]]</span><br><span class="line">void transfer(name from,name to, asset quantity, string memo);</span><br></pre></td></tr></table></figure></p><p>而ABI的表现形式为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"transfer"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"transfer"</span>,</span><br><span class="line">    <span class="string">"ricardian_contract"</span>: <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上述描述可以看出，在方法的类型定义关联了前面的隐性结构体类型。虽然在此处，方法名与隐性结构体类型命名一致，但实际情况并不一定非要相同。</p><hr><p><strong>表定义(Table)</strong><br>关于表的ABI定义，相比其他几种定义要稍复杂一些。具体JSON定义如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"type"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"index_type"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"key_names"</span> : [],</span><br><span class="line">  <span class="string">"key_types"</span> : []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JSON中字段说明如下:</p><ul><li>name<br>  合约初始化表时所要使用的名称</li><li>type<br>  表对应的数据结构体。也就是前面所说的显性结构体类型</li><li>index _type<br>  此类型为表主键类型</li><li>key _names<br>  索引字段列表</li><li>key_types<br>  索引字段数据类型列表。数据长度与索引字段列表长度一致。需要说明的是索引字段类型，只支持uint64_t,uint128 _t,uint256 _t,double,long double五种类型<br>示例：eosio.token合约中的accounts表</li><li><p>ABI表定义</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"accounts"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"account"</span>,</span><br><span class="line">    <span class="string">"index_type"</span>: <span class="string">"i64"</span>,</span><br><span class="line">    <span class="string">"key_names"</span>: [<span class="string">"primary_key"</span>],</span><br><span class="line">    <span class="string">"key_types"</span>: [<span class="string">"uint64"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>表合约代码</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct [[eosio::table]] account &#123;</span><br><span class="line">    asset    balance;</span><br><span class="line"></span><br><span class="line">    uint64_t primary_key()const &#123; <span class="built_in">return</span> balance.symbol.code().raw(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>从表合约代码可以看来，只需要在数据结构体代码中添加eosio-table标签就可以完成对表的定义操作。</p><p>之所以提供多索引的实现，主要还是为了应对业务场景中不同维度的数据查询，而且支持按升序或降序的遍历方式处理业务。</p><hr><p><strong>ricardian条款(ricardian_clauses)</strong><br>该数组主要用于定义一种基于文本的合约宪法。通过其与智能合约的整合，来解决一些无法通过程序来判定的情况。</p><p>示例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"ricardian_clauses"</span>: [&#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="string">"Warranty"</span>,</span><br><span class="line">      <span class="string">"body"</span>: <span class="string">"WARRANTY. The invoker of the contract action shall uphold its Obligations under this Contract in a timely and workmanlike manner, using knowledge and recommendations for performing the services which meet generally acceptable standards set forth by EOS.IO Blockchain Block Producers.\n\n"</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="string">"Default"</span>,</span><br><span class="line">      <span class="string">"body"</span>: <span class="string">"DEFAULT. The occurrence of any of the following shall constitute a material default under this Contract: \n\n"</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="string">"Remedies"</span>,</span><br><span class="line">      <span class="string">"body"</span>: <span class="string">"REMEDIES. In addition to any and all other rights a party may have available according to law, if a party defaults by failing to substantially perform any provision, term or condition of this Contract, the other party may terminate the Contract by providing written notice to the defaulting party. This notice shall describe with sufficient detail the nature of the default. The party receiving such notice shall promptly be removed from being a Block Producer and this Contract shall be automatically terminated. \n  \n"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></p><p>我们可以针对智能合约或者具体的合约方法，附加上对应的文本合约描述。比如针对方法的文本合约定义:</p><ul><li><p>ABI定义</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"actions"</span>: [&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"hi"</span>,</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"hi"</span>,</span><br><span class="line">    <span class="string">"ricardian_contract"</span>: <span class="string">"# CONTRACT FOR hello::hi## ACTION NAME: hi\n### Parameters### Parameters\nInput parameters:Input parameters:\n\n* `user` (string to include in the output)* `user` (string to include in the output)\n\nImplied parameters: Implied parameters: \n\n* `account_name` (name of the party invoking and signing the contract)* `account_name` (name of the party invoking and signing the contract)\n\n### Intent### Intent\nINTENT. The intention of the author and the invoker of this contract is to print output. It shall have no other effect.INTENT. The intention of the author and the invoker of this contract is to print output. It shall have no other effect.\n\n### Term### Term\nTERM. This Contract expires at the conclusion of code execution.TERM. This Contract expires at the conclusion of code execution.\n"</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></li><li><p>代码及文件定义（hello.hi_rc.md）</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CONTRACT FOR hello::hi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## ACTION NAME: hi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Parameters</span></span><br><span class="line">Input parameters:</span><br><span class="line"></span><br><span class="line">* `user` (string to include <span class="keyword">in</span> the output)</span><br><span class="line"></span><br><span class="line">Implied parameters:</span><br><span class="line"></span><br><span class="line">* `account_name` (name of the party invoking and signing the contract)</span><br><span class="line"></span><br><span class="line"><span class="comment">### Intent</span></span><br><span class="line">INTENT. The intention of the author and the invoker of this contract is to <span class="built_in">print</span> output. It shall have no other effect.</span><br><span class="line"></span><br><span class="line"><span class="comment">### Term</span></span><br><span class="line">TERM. This Contract expires at the conclusion of code execution.</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>ABI Extensions</strong><br>该功能将允许用户进行自定义区块扩展， 包括对数据的签名、编码等。不过现在该属性暂未被应用支持。</p><hr><p>到此，相信大家对于整个ABI文件的结构应该有了大体的认识与理解。这样大家可以在研究其他智能合约时，可以首先阅读对方的ABI文件，就可以熟悉对方的整体接口框架。</p><hr><blockquote><p>在教程中如出现错误🐛或不易理解的知识点，欢迎加我微信指正!<br>Name: zhangliang | WeChat: rushking2009 | Mail: <a href="mailto:zhangliang@cldy.org" target="_blank" rel="noopener">zhangliang@cldy.org</a></p></blockquote><hr><p><strong>changelog</strong><br>2019-03-07 <a href="mailto:zhangliang@cldy.org" target="_blank" rel="noopener">zhangliang</a></p><ul><li>初次发稿</li></ul>]]></content>
    
    <summary type="html">
    
      每个EOS合约开发者肯定都知道ABI文件，但却不一定都知道ABI内部属性是什么，具体作用。本文hackdapp将带你一探ABI究竟。HackDApp愿与你分享！
    
    </summary>
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/categories/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/tags/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
      <category term="EOS合约开发教程" scheme="https://www.hackdapp.com/tags/EOS%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"/>
    
      <category term="EOS完全开发手册" scheme="https://www.hackdapp.com/tags/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/"/>
    
      <category term="eos smart abi" scheme="https://www.hackdapp.com/tags/eos-smart-abi/"/>
    
  </entry>
  
  <entry>
    <title>重塑思维：自律 VS 习惯</title>
    <link href="https://www.hackdapp.com/archives/rebuildbrain_habit.html"/>
    <id>https://www.hackdapp.com/archives/rebuildbrain_habit.html</id>
    <published>2019-02-14T07:46:39.000Z</published>
    <updated>2019-02-14T08:09:21.733Z</updated>
    
    <content type="html"><![CDATA[<p><strong>自律使我压抑，习惯助我成长。</strong> 自律与习惯，其实目标都是一致的，只是所产生的行动动力源是不相同的。</p><p>相信每个人都在不停的思考一个问题，“我如何才能使明天的自己比今天的自己更加优秀一些呢？”</p><p>为了让自己变得更好，我们去总结规律，改变自我认知，希望能从不断的思维升级过程中，锻造出属于自己的思维工具，培养及丰富问题症结的方案库。</p><p>为了让自己变得更好，我们需要靠意志去坚持去做一件让自己变得优秀的事情，但你发现一段时间之后，这件事不了了知，扔那儿放下了，因为这样的事在我的人生当中简直太熟悉不过了。</p><p>相反，有一些行为却长期固化下来了，比如我们的一些日常洗漱习惯，即使你中途有一段时间没去做，那你也不会放弃这件事。</p><p>当某一种行为已经成为你的习惯时，如果你有意识的去观察一下，会发现一些许规律。比如：刷牙，可能现在没有不早晚刷牙的童鞋吧。不妨想一想这个行为大家保持了多少年，到现在是否还需要各种精神动力去推着自己去做这个事吗？</p><p>明显不需要，可以说这已经是写入自己骨头里的一种惯性行为，你要是不注意都不发现它原来其实就是一个号的学习榜样。因为它太习以为常了，平常的都忘掉它的存在。</p><p>那既然刷牙可以养成习惯，那我们其他行为为啥就不能养成一种习惯呢？</p><p>首先，处于习惯性的行为执行过程并不会让你特别有心理负担；<br>其次，习惯中的行为并不会消耗自己稀缺的精力；<br>最后，行为关联及导向性。也就是习惯行为之间的联动开关。比如：洗漱的时候总能与刷牙这件事产生一定的链接，而这个链接往往就是我们通过意识去不断增强脑回路而形成的。</p><p>之所以总结这些，就是因为我身上的一件事，当时看李笑来的专栏里曾经提到一种感受，就是“不做这件事就难受”。 当时是在是无法理解这种状态，除了吃饭这件事，找不出天天不做就难受的事来，当你无法从自身找到可以参考的例子时，你总是无法理解其概念。</p><p>直到我发现身上这件事，<code>刮胡子</code>。对，你没看错，就是刮胡子。</p><p>为什么讲呢？因为之前总是用电动剃须刀，总是容易忘记用，时做时不做的，而且刮的也不是太干净。直到有一天看到京东做活动卖手动剃须刀，想着买来试一试，但当时也犹豫，每天早上用这个会不会特花时间啊。</p><p>但事实证明，相比电动剃须刀，手动的虽然要麻烦一些，时间也要多花费一些。但这件事我却坚持了一年，直至今日从心理感受来讲，自己并没有感觉每天要逼着自己去做这件事，而是很自觉的每天洗漱后自动进入刮胡子状态。</p><p>为什么会这样呢？因为每一次刮完胡子，对着镜子一照，感觉干净清爽，漂亮，帅气。让我从内心看到一个舒服的自己，这算不算是一种仪式感呢。</p><p>后来，我总结了一下习惯养成的一个关键因素：持续的心理反馈。反馈可以让我们感受到变化与进步，或是一种心理满足；而持续性一来可以增强行为的动力，二过可以慢慢促进脑回路的链接建立。</p><p>那么，如何建立自己的习惯养成路径呢？那就是</p><ol><li>先制定一个你绝对认可其价值的目标；</li><li>在意识中建立诱导因子，也就是你需要在已形成的习惯之中，建立一个与新行动的触感连接；</li><li>持续反馈，每天都要总结，让自己内心见证成长，而后通过持续达到巩固行动的动力。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>好的习惯、应用技巧及思维方式是可以产生复利效应价值的，关键在于它不是形式上的应用，不是为技巧而技巧，一定是在我们的生活或工作实际场景中解决实际问题，并以此不断反馈价值收获，而持续的价值收益又会加强我们执行的动力，最终形成一个正向向上的良性循环♻️。</p><p>执行力其实是落实行动的第一要素，所以我们需要学会如何去补充这项能源。而最好的方式就是让自己认可这件事的价值。并且能够在做事的过程中，有深刻的反馈与心理感受，学会记录自己的心理变化。</p><p>最后，通过不断的执行与反馈，增强我们的脑回路链接。久而久之，就会成为我们的习惯。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;自律使我压抑，习惯助我成长。&lt;/strong&gt; 自律与习惯，其实目标都是一致的，只是所产生的行动动力源是不相同的。&lt;/p&gt;
&lt;p&gt;相信每个人都在不停的思考一个问题，“我如何才能使明天的自己比今天的自己更加优秀一些呢？”&lt;/p&gt;
&lt;p&gt;为了让自己变得更好，我们
      
    
    </summary>
    
      <category term="重塑思维" scheme="https://www.hackdapp.com/categories/%E9%87%8D%E5%A1%91%E6%80%9D%E7%BB%B4/"/>
    
    
      <category term="重塑思维" scheme="https://www.hackdapp.com/tags/%E9%87%8D%E5%A1%91%E6%80%9D%E7%BB%B4/"/>
    
      <category term="自律与习惯" scheme="https://www.hackdapp.com/tags/%E8%87%AA%E5%BE%8B%E4%B8%8E%E4%B9%A0%E6%83%AF/"/>
    
      <category term="思维认知" scheme="https://www.hackdapp.com/tags/%E6%80%9D%E7%BB%B4%E8%AE%A4%E7%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>C++基础语法（EOS完全开发指南）</title>
    <link href="https://www.hackdapp.com/archives/eosdev_cplus_basic.html"/>
    <id>https://www.hackdapp.com/archives/eosdev_cplus_basic.html</id>
    <published>2019-01-28T10:16:50.000Z</published>
    <updated>2019-02-21T07:40:16.455Z</updated>
    
    <content type="html"><![CDATA[<p><code>Author: zhangliang | WeChat: rushking2009 | Mail: zhangliang@cldy.org</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* filename: myapp.cpp</span></span><br><span class="line"><span class="comment">   date: 2019-01-28 3:06 PM</span></span><br><span class="line"><span class="comment">   auth: zhangliang&lt;zhangliang@cldy.org&gt; */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //定义头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;    <span class="comment">//命令空间, 简化后续变量或方法调用。e.g. std::string 等同于 string</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> msg = <span class="string">"hi, my first dapp"</span>; <span class="comment">//定义变量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; msg &lt;&lt;<span class="built_in">endl</span>; <span class="comment">//打印字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tryit: http://tpcg.io/Tulum1</span></span><br></pre></td></tr></table></figure><p>以上代码便是C++最简单可运行的最小示例。基本包含了在程序结构中所必须的一些语言特性。</p><p>根据上述程序结构，我们可以大致将它拆分成五部分内容：</p><a id="more"></a><h2 id="1-include-lt-iostream-gt"><a href="#1-include-lt-iostream-gt" class="headerlink" title="1. #include &lt;iostream&gt;"></a>1. <code>#include &lt;iostream&gt;</code></h2><p>头文件定义主要用于引用第三方函数库，通过调用第三方函数可以减少开发代码量，提高开发效率，同时也避免了不必要的重复造轮子。</p><p>比如：通过引用<code>&lt;cmath&gt;</code>库，可以帮助我们快速使用里面的函数进行一些数学运算。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzmer35re6j30l30j6myt.jpg" alt="函数列表"></p><p>所以，后续我们需要学会便是如何查阅C++文档库，不断积累与完善对于第三方标准库的方法学习与理解。</p><h2 id="2-int-main"><a href="#2-int-main" class="headerlink" title="2. int main()"></a>2. <code>int main()</code></h2><p><code>main</code>函数区别于其它普通函数之处在于: main函数默认被系统定义为应用入口调用方法。除此之外，与其他函数无任何区别。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sayHi</span><span class="params">(<span class="built_in">string</span> username)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">"hi, "</span>).append(username).append(<span class="string">"!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sayHi(<span class="string">"www.hackdapp.com"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tryit: http://tpcg.io/uHUkzy</span></span><br></pre></td></tr></table></figure><p>函数定义，其实对于所有编程语言的定义方式大致相同, 都可以表现为以下形式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;返回类型|<span class="keyword">void</span>&gt; 方法名(参数定义<span class="number">1</span>, 参数定义<span class="number">2</span>，参数定义...)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//do some stuff</span></span><br><span class="line">    <span class="keyword">return</span> &lt;返回数据&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你之前已经在使用其他编程语言，那么应该对于C++其实也可以很好的理解它的程序结构。</p><p>注： 在后续的第二部分，我们会详细介绍函数的多种定义及使用方式，包括形参实参、重载以及虚函数等。</p><h2 id="3-string-message-quot-hi-my-first-app-quot"><a href="#3-string-message-quot-hi-my-first-app-quot" class="headerlink" title="3. string message = &quot;hi, my first app&quot;"></a>3. <code>string message = &quot;hi, my first app&quot;</code></h2><p>变量定义，在程序开发过程，往往需要定义一些临时变量，用于存储在数据逻辑处理过程所必须的临时存储。</p><p>而变量的类型，主要分为字符、整型，长/短整型、单精度、双精度、布尔类型以及字符串。<br>我们在实际应用场景中，需要明确了解与知道这些基础数据类型的定义及边界范围，比如，无符号整型、单精度。</p><p>尤其是对数字类型的字段，如果不了解其边界范围，很可能会导致运算溢出等问题，特别是在合约开发过程中，数字溢出很可能导致的便是相当大的经济损失。</p><p>换个角度讲，合理的使用变量类型，也可能在一定程序中节省资源的浪费。因为在EOS合约中存储数据是需要消耗资源的。</p><p>另外，对于变量的名称定义，其名称只能是由数字、字母以及下划线组成且不可能以数字开头，而且根据不同平台，对于名称的长度其实也是存在限制的。</p><h2 id="4-cout-lt-lt-msg-lt-lt-endl"><a href="#4-cout-lt-lt-msg-lt-lt-endl" class="headerlink" title="4. cout &lt;&lt; msg &lt;&lt;endl"></a>4. <code>cout &lt;&lt; msg &lt;&lt;endl</code></h2><p><code>cout</code>是<code>iostream</code>函数库中的一个流数据输出函数，一般用于在程序调用过程向控制台输入一些调试信息；与此对应的是<code>cin</code>, 用于接收输入数据流。</p><p>不过, 在EOS合约中无法调用此函数。举而代之的是，EOSLIB库自己封装的<code>print</code>函数.</p><h2 id="5-单行注解-or-多行注解"><a href="#5-单行注解-or-多行注解" class="headerlink" title="5. //单行注解 or /*多行注解*/"></a>5. <code>//单行注解 or /*多行注解*/</code></h2><p>在程序开发过程，往往需要通过语言描述某个代码文件所要实现的整体功能或者某个函数的功能、参数及约束说明。这时候就需要用到注解。</p><p>而注解同样也所有的编程语言中也大致相同，一般分为单行注释与多行注释。</p><p>单行注释适用于短小的描述某一行运行逻辑；而多行注释多用于描述函数说明以及文件功能说明。</p><hr><p><code>注：</code> 在教程中如出现不易理解或存在错误的问题🐛，欢迎评论留言！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Author: zhangliang | WeChat: rushking2009 | Mail: zhangliang@cldy.org&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/* filename: myapp.cpp&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;   date: 2019-01-28 3:06 PM&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;   auth: zhangliang&amp;lt;zhangliang@cldy.org&amp;gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;iostream&amp;gt; //定义头文件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;;    &lt;span class=&quot;comment&quot;&gt;//命令空间, 简化后续变量或方法调用。e.g. std::string 等同于 string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt; msg = &lt;span class=&quot;string&quot;&gt;&quot;hi, my first dapp&quot;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//定义变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; msg &amp;lt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;//打印字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//tryit: http://tpcg.io/Tulum1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以上代码便是C++最简单可运行的最小示例。基本包含了在程序结构中所必须的一些语言特性。&lt;/p&gt;
&lt;p&gt;根据上述程序结构，我们可以大致将它拆分成五部分内容：&lt;/p&gt;
    
    </summary>
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/categories/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/tags/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
      <category term="C++导读" scheme="https://www.hackdapp.com/tags/C-%E5%AF%BC%E8%AF%BB/"/>
    
      <category term="EOS合约开发教程" scheme="https://www.hackdapp.com/tags/EOS%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++导读（EOS完全开发指南）</title>
    <link href="https://www.hackdapp.com/archives/eosdev_cplus_intro.html"/>
    <id>https://www.hackdapp.com/archives/eosdev_cplus_intro.html</id>
    <published>2019-01-28T10:08:35.000Z</published>
    <updated>2019-01-28T10:56:43.903Z</updated>
    
    <content type="html"><![CDATA[<p><code>Author: zhangliang | WeChat: rushking2009 | Mail: zhangliang@cldy.org</code></p><p>本章节内容主要是带大家了解C++整个编程语言的体系架构，对C++编程语言有个整体的大致的认识与理解。另外，也是帮助大家在开发EOS智能合约之前做一下前期预习，易于对后面EOS合约的快速上手。</p><p>另外，需要说明的是，因为本身EOS智能合约是在一个沙箱机制中运行，所以它对一些标准函数库的方法进行了一些限制。所以可能导致大家可能在网上找的资料中的方法无法在合约中正常执行。</p><a id="more"></a><p>另一个角度讲，正是由于这种限制，也是减小了我们的学习范围，这样我们就不需要完全掌握的整个C++的语言体系，便可以开发智能合约。比如：文件操作读取，时间函数，随机数，这些在EOS合约里是都不可用的。 不过，有一个问题就是你无法明确知道哪些功能被禁用了，只能去试。或者官网有说明，可能我没有看到而已。</p><p>在整个开发过程，你只需要学会使用一些基础语法，简单数据类型、数据结构以及常用的一些工具库。比如：如何处理字符串，如何存储或操作数据结构。</p><p>除此之外，再掌握一些程序设计技巧，就可以实战开发自己的DApp应用了，而本身程序设计其实是与哪种程序语言不存在直接关系的，只是让你的程序有更好的应对扩展。</p><p>通过本章节内容你可以学会：</p><ul><li>对基础数据类型以及它们的数据边界有清晰的认识;</li><li>学会如何使用不同数据结构处理业务场景中的问题；</li><li>学会如何定义自己的函数；</li><li>学会如何面对对象的思维设计自己的合约；</li><li>学会如何通过模板封装形成自己的工具库；</li><li>了解一些常用的标准库文件及常用的函数工具方法；</li><li>学会如何通过手册查找工具函数</li></ul><hr><p>本章节，将会从以下八个部分进行分类介绍：</p><p>1.1 C++基础语法<br>1.2 基础数据类型及变量、常量定义<br>1.3 结构体及函数定义<br>1.4 数据结构<br>1.5 面向对象编程<br>1.6 高级应用(模板定义)<br>1.7 标准库及库函数<br>1.8 资源及经验分享</p><hr><p><code>注：</code> 在教程中如出现不易理解或存在错误的问题🐛，欢迎评论留言！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Author: zhangliang | WeChat: rushking2009 | Mail: zhangliang@cldy.org&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;本章节内容主要是带大家了解C++整个编程语言的体系架构，对C++编程语言有个整体的大致的认识与理解。另外，也是帮助大家在开发EOS智能合约之前做一下前期预习，易于对后面EOS合约的快速上手。&lt;/p&gt;
&lt;p&gt;另外，需要说明的是，因为本身EOS智能合约是在一个沙箱机制中运行，所以它对一些标准函数库的方法进行了一些限制。所以可能导致大家可能在网上找的资料中的方法无法在合约中正常执行。&lt;/p&gt;
    
    </summary>
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/categories/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="EOS完全开发指南" scheme="https://www.hackdapp.com/tags/EOS%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
      <category term="C++导读" scheme="https://www.hackdapp.com/tags/C-%E5%AF%BC%E8%AF%BB/"/>
    
      <category term="EOS合约开发教程" scheme="https://www.hackdapp.com/tags/EOS%E5%90%88%E7%BA%A6%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>坚持的长性</title>
    <link href="https://www.hackdapp.com/archives/think_habit.html"/>
    <id>https://www.hackdapp.com/archives/think_habit.html</id>
    <published>2019-01-21T01:31:24.000Z</published>
    <updated>2019-02-14T07:48:43.866Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fzdyksu0ykj30qy0dw400.jpg" alt=""></p><p>今天早上算是被媳妇嘲笑了一番，为啥呢？</p><p>因为之前自己有一段时间，为了背英语单词，所以早起了一个月，而如今早一天晚一天，早起完全看心情。</p><p>媳妇给出的评价就是：用劲过猛，要么及早要么极迟，完全是一种过激行为。</p><p>同时她也给出建议：只要比上班的时间多出一小时其实就可以做很多事情。重要的是常态化。</p><hr><p>2019开始了，自己确没开始。以前都早早给自己作出各种规划，对比现在，还不如之前的自己吗？不应该是每年比前一年好一些吗或者每天比昨天好一些吗？</p><p>哦，也可能是最近超忙，导致各种规划的推迟。但内心同时又会想起另外一种声音：不，你不是，你只是懒。事情没把你逼到一种绝境上，你是不会立即行动的。</p><h2 id="2019要做的事"><a href="#2019要做的事" class="headerlink" title="2019要做的事"></a>2019要做的事</h2><ol><li>早起，不早起怎么做重要的事；而且希望能找到一些习惯思维方式；</li><li>持续写作，写一本自己的技术书籍，打造自己的硬核；</li><li>持续总结，不犯过去犯的错，少走弯路；</li><li>思考习惯养成路径，以便培养自己新习惯的有效成功率</li></ol><p>注：事情不在多，夯实好这几点。</p><h2 id="目前的状态"><a href="#目前的状态" class="headerlink" title="目前的状态"></a>目前的状态</h2><ul><li>时不时早起起来做一些事情，可能是工作上的，也可能是生活上的，但缺少对书的阅读；另外，感觉早上精力特别出奇的好，是否应该做一些最重要的事情，而读书的化放在晚上的时候。</li><li>未达到持续写东西的地步，需要检讨；可能存在的原因: 对于第二天早上要写的东西，前一天没有大致规划；或者说并不需要规划，每天早上写的时候就按之前的套路写就可以了，不讲究一次写完写完美，而是持续写出自己的每个内容点，草稿结束后再修改，也是告诉自己好文章是持续修改出来的，不可能写完就扔那儿了，而是要持续完善。包括今天写的这篇，其实也是由之前早上写的卡片扩展而来的。</li><li>总结之前过于重视形式化。总结对于我来讲，总感觉认可但又未给予足够的重视，因为总是断断续续的写一些自检清单。可能这个和习惯的养成也是一样，归根到底是没有成长的即视感，也就是没有反馈。比如：刮胡子，为什么要举这个例子呢？因为之前用电动剃须刀时，总是时不时刮一次；而用手动刮胡刀后，发现自己几乎每天都会坚持这件事。当时再想为什么这件事能坚持的如此之前呢？那其他事情怎么不能坚持下去呢？我是否能够从刮胡子这件事情中找到自己内心的那一份认识与感受呢。后来才发现，那是因为刮胡子这件事能让我内心出现一份好形象不邋遢的意识。洗漱的时候就是在潜意识里调动这份动力，而且在刮完胡子后更加让自己内心得以满足，这不正是一种仪式感吗？</li><li>正在有意识，感受自己每天坚持做一件事情的内心是如何的？</li></ul><p>所以，如果要让某个行为成为你的习惯，你就要从内心上提高对它的认可，以及最重要的一件事，你要寻找你的内心感受，是什么让你满足。如果这个不好理解的话，我给你的建议就是观察你已有的习惯中想想那是一种什么感觉，做个比较可能会更形象一些。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79gy1fzdyksu0ykj30qy0dw400.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天早上算是被媳妇嘲笑了一番，为啥呢？&lt;/p&gt;
&lt;p&gt;因为之前自己有一段时间，为了背英语单
      
    
    </summary>
    
      <category term="重塑思维" scheme="https://www.hackdapp.com/categories/%E9%87%8D%E5%A1%91%E6%80%9D%E7%BB%B4/"/>
    
    
      <category term="习惯养成" scheme="https://www.hackdapp.com/tags/%E4%B9%A0%E6%83%AF%E5%85%BB%E6%88%90/"/>
    
      <category term="仪式感" scheme="https://www.hackdapp.com/tags/%E4%BB%AA%E5%BC%8F%E6%84%9F/"/>
    
      <category term="内心的满足" scheme="https://www.hackdapp.com/tags/%E5%86%85%E5%BF%83%E7%9A%84%E6%BB%A1%E8%B6%B3/"/>
    
      <category term="2019要做的事" scheme="https://www.hackdapp.com/tags/2019%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>HackDApp学习周报02W:如何成为演讲的高手</title>
    <link href="https://www.hackdapp.com/archives/weekly08.html"/>
    <id>https://www.hackdapp.com/archives/weekly08.html</id>
    <published>2019-01-20T16:38:26.000Z</published>
    <updated>2019-02-21T09:14:18.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="知识学习"><a href="#知识学习" class="headerlink" title="知识学习"></a>知识学习</h1><ul><li><a href="http://joinwee.com/lesson/20/#4" target="_blank" rel="noopener">TED深度学习四步法</a><br>何为组块</li><li><a href="得到">如保成为演讲的高手</a></li></ul><hr><h1 id="思维成长"><a href="#思维成长" class="headerlink" title="思维成长"></a>思维成长</h1><hr><h1 id="软件工具"><a href="#软件工具" class="headerlink" title="软件工具"></a>软件工具</h1><hr><h1 id="书籍阅读"><a href="#书籍阅读" class="headerlink" title="书籍阅读"></a>书籍阅读</h1><ul><li>变量<br>罗振宇推荐， 从现象中看到本质；</li><li>创新算法<br>阳志平博客推荐</li></ul><hr><h1 id="好玩的事"><a href="#好玩的事" class="headerlink" title="好玩的事"></a>好玩的事</h1><ul><li></li></ul><hr><h1 id="vlog"><a href="#vlog" class="headerlink" title="vlog"></a>vlog</h1><ol><li>如何制作自己的vlog<br>风格确定； 编写脚本； 根据脚本选择镜头录制； 视频剪辑。</li><li>如何制作转场、添加字幕<br>youtube里资源还是蛮多的，购买相关插件</li><li>如何找免费音乐<br>B站资源推荐</li></ol><hr><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><a href="https://www.datascienceweekly.org/newsletters/data-science-weekly-newsletter-issue-272" target="_blank" rel="noopener">https://www.datascienceweekly.org/newsletters/data-science-weekly-newsletter-issue-272</a></p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g0e568svouj30t64cs7k4.jpg" alt="xx"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;知识学习&quot;&gt;&lt;a href=&quot;#知识学习&quot; class=&quot;headerlink&quot; title=&quot;知识学习&quot;&gt;&lt;/a&gt;知识学习&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://joinwee.com/lesson/20/#4&quot; target=&quot;_blank
      
    
    </summary>
    
      <category term="周报(2019)" scheme="https://www.hackdapp.com/categories/%E5%91%A8%E6%8A%A5-2019/"/>
    
    
      <category term="学习周报" scheme="https://www.hackdapp.com/tags/%E5%AD%A6%E4%B9%A0%E5%91%A8%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>波场Tron-可快捷开发的实战工程模板</title>
    <link href="https://www.hackdapp.com/archives/tron_boilerplate.html"/>
    <id>https://www.hackdapp.com/archives/tron_boilerplate.html</id>
    <published>2019-01-11T22:42:54.000Z</published>
    <updated>2019-03-14T01:23:20.550Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> _                         _           _ _                 _       _</span><br><span class="line">| |_ _ __ ___  _ __       | |__   ___ (_) | ___ _ __ _ __ | | __ _| |_ ___</span><br><span class="line">| __| <span class="string">'__/ _ \| '</span>_ \ _____| <span class="string">'_ \ / _ \| | |/ _ \ '</span>__| <span class="string">'_ \| |/ _` | __/ _ \</span></span><br><span class="line"><span class="string">| |_| | | (_) | | | |_____| |_) | (_) | | |  __/ |  | |_) | | (_| | ||  __/</span></span><br><span class="line"><span class="string"> \__|_|  \___/|_| |_|     |_.__/ \___/|_|_|\___|_|  | .__/|_|\__,_|\__\___|</span></span><br><span class="line"><span class="string">                                                    |_|</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/ChainDesk/tron_boilerplate" target="_blank" rel="noopener"><strong> Tron-Boilerplate</strong></a>, 是基于Tron公链的一套可快速搭建本地私链环境、发布合约以及配置完整的标准工程模板。</p><p>该工程模板旨在于帮助大家快速工程化本地开发环境，减少环境搭建以及调试开发流程过程中所需花费的大量时间，让大家将更多精力投入到产品设计与核心业务逻辑实现上。</p><p>使用提供的工程模板，可从以下四个方面提升开发效率：</p><ul><li>一键启动或暂停私链环境</li><li>一键编译智能合约</li><li>一键发布智能合约</li><li>一键单元测试（jtest）</li></ul><p>同时，本工程模板附带了一个完整的示例代码(<strong>Todolist</strong>)，可供大家参考与学习。示例效果如下：</p><a id="more"></a><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fz354rjq8wg30go09sti8.gif" alt=""></p><p>最后，开发人员只需按照项目工程结构，编写自己的智能合约、前端页面及与SDK交互逻辑即可。</p><hr><h2 id="前置依赖"><a href="#前置依赖" class="headerlink" title="前置依赖"></a>前置依赖</h2><h3 id="1-安装docker"><a href="#1-安装docker" class="headerlink" title="1. 安装docker"></a>1. 安装docker</h3><p><strong> Install Docker for Mac</strong> : <a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="noopener">https://docs.docker.com/docker-for-mac/</a><br><strong> Install Docker for Windows</strong>: <a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">https://docs.docker.com/docker-for-windows/install/</a></p><p>更多资料可参考: <a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com</a></p><h3 id="2-安装node"><a href="#2-安装node" class="headerlink" title="2. 安装node"></a>2. 安装node</h3><p>To install or update nvm, you can use the install script using cURL:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash</span><br></pre></td></tr></table></figure></p><p>or wget<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash</span><br></pre></td></tr></table></figure></p><p>The script clones the nvm repository to /.nvm and adds the source line to your profile (/.bash_profile, /.zshrc, /.profile, or /.bashrc)._</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$&#123;XDG_CONFIG_HOME/:-$HOME/.&#125;</span>nvm"</span></span><br><span class="line">[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> <span class="comment"># This loads nvm</span></span><br></pre></td></tr></table></figure><p>更多资料可参考: <a href="https://github.com/creationix/nvm#installation" target="_blank" rel="noopener">https://github.com/creationix/nvm#installation</a></p><h3 id="3-安装jdk8"><a href="#3-安装jdk8" class="headerlink" title="3. 安装jdk8"></a>3. 安装jdk8</h3><p>JDK8: <a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><p>如果大家不使用tron提供的tron-studio开发合约的化，可以选择不安装此项。因为使用tronbox同样也可以编译以及发布合约。</p><h3 id="4-安装tronbox"><a href="#4-安装tronbox" class="headerlink" title="4. 安装tronbox"></a>4. 安装tronbox</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g tronbox</span><br></pre></td></tr></table></figure><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fz36n5t5vqj30gk0b1aad.jpg" alt=""></p><p>注：对于最新的 Java-Tron Odyssey 3.2 版本，最小兼容的 TronBox 版本是 TronBox 2.2.1。请确保您已安装此版本。</p><p>更多资料：<a href="https://cn.developers.tron.network/docs/%E5%85%A5%E9%97%A8" target="_blank" rel="noopener">https://cn.developers.tron.network/docs/%E5%85%A5%E9%97%A8</a></p><h3 id="5-开发工具"><a href="#5-开发工具" class="headerlink" title="5. 开发工具"></a>5. 开发工具</h3><p>开发工具可根据自己喜好自由选择，个人比较推荐<strong>VSCode</strong>。</p><p>官网链接：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></p><h2 id="工程安装与使用"><a href="#工程安装与使用" class="headerlink" title="工程安装与使用"></a>工程安装与使用</h2><h3 id="1-克隆工程"><a href="#1-克隆工程" class="headerlink" title="1. 克隆工程"></a>1. 克隆工程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:ChainDesk/tron_boilerplate.git</span><br></pre></td></tr></table></figure><p><strong>工程结构介绍</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 项目地址: https://github.com/ChainDesk/tron_boilerplate</span></span><br><span class="line"><span class="comment"># 注：待工程稳定后，可能会考虑做成插件，可使用yeoman快速构建，欢迎大家star.</span></span><br><span class="line">.</span><br><span class="line">├── README.md</span><br><span class="line">├── bin</span><br><span class="line">│   ├── libs</span><br><span class="line">│   │   └── TronStudio.jar//TronStudio开发工具包</span><br><span class="line">│   ├── start_docker.sh//启动私链</span><br><span class="line">│   ├── start_tronstudio.sh//启动TronStudio</span><br><span class="line">│   └── stop_docker.sh//停止私链</span><br><span class="line">├── build//合约编译生成目录</span><br><span class="line">│   └── contracts</span><br><span class="line">│       ├── HelloWorld.json//示例合约ABI, HelloWorld</span><br><span class="line">│       ├── Migrations.json</span><br><span class="line">│       └── TodoList.json           //示例合约ABI, TodoList</span><br><span class="line">├── contracts//合约目录，大家合约都放在这儿</span><br><span class="line">│   ├── HelloWorld.sol</span><br><span class="line">│   ├── Migrations.sol</span><br><span class="line">│   └── TodoList.sol</span><br><span class="line">├── migrations//发布合约目录</span><br><span class="line">│   ├── 1_initial_migration.js</span><br><span class="line">│   └── 2_deploy_contracts.js       //新添加的合约需要在此文件中定义，否则无法通过tronbox deploy命令发布</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json//前端App工程及依赖包定义，以及多个服务启动命令。</span><br><span class="line">├── public</span><br><span class="line">│   ├── favicon.ico</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   └── manifest.json</span><br><span class="line">├── src//前端React代码目录</span><br><span class="line">│   ├── TodoList.js                 </span><br><span class="line">│   ├── contracts</span><br><span class="line">│   │   └── TodoList.json           //合约ABI文件</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   ├── serviceWorker.js</span><br><span class="line">│   └── tronweb.js                  //新启动的工程，需要根据私链生成的私钥以及新发布的合约地址在此重新修改。</span><br><span class="line">├── <span class="built_in">test</span>//jtest测试目录，方便大家编写测试用例</span><br><span class="line">│   └── web.test.js</span><br><span class="line">├── tronbox-config.js</span><br><span class="line">└── tronbox.js//发布合约所依赖的配置，此文件定义了本地、测试以及正式网络的http访问地址</span><br><span class="line"></span><br><span class="line">12 directories, 27 files</span><br></pre></td></tr></table></figure></p><h3 id="2-工程初始化"><a href="#2-工程初始化" class="headerlink" title="2. 工程初始化"></a>2. 工程初始化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>这一步主要用于更新前端框架react所依赖的包文件，依赖包安装成功后，会在工程目录下看到一个<code>node_modules</code>文件夹。</p><p>如果你的前端选型不是react的化，也可根据自己需求进行依赖包配置修改。</p><h3 id="3-正式开发流程"><a href="#3-正式开发流程" class="headerlink" title="3. 正式开发流程"></a>3. 正式开发流程</h3><h4 id="3-1-启动链环境"><a href="#3-1-启动链环境" class="headerlink" title="3.1 启动链环境"></a>3.1 启动链环境</h4><p>执行<code>cmd+shift+p</code>，调用vscode的命令列表，选择run task从中选择start_docker任务_</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fz37ttdzdsg30go09sn7r.gif" alt=""><br>同样，如果要停止当前docker环境，只需选择stop_docker脚本即可。_</p><p>所有的执行任务配置默认只存在两个地方:</p><ul><li>tron_boilerplate/.vscode/tasks.json_</li><li>package.json中的scripts<br>大家可根据自己需要进行添加或修改，而且也可以通过IDE本身的快捷键映射对应的任务。</li></ul><h4 id="3-2-发布合约"><a href="#3-2-发布合约" class="headerlink" title="3.2 发布合约"></a>3.2 发布合约</h4><p>运行task任务，然后从中选择<code>npm deploy</code>, 即可发布当前所有合约至私链环境。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fz380y3oeog30go0907wh.gif" alt=""></p><p>合约发布成功后，会显示如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Using network <span class="string">'development'</span>.</span><br><span class="line"></span><br><span class="line">Running migration: 1_initial_migration.js</span><br><span class="line">  Replacing Migrations...</span><br><span class="line">  Migrations:</span><br><span class="line">    (base58) TBC7CqpjBxGUt9Z9hhM4QNRFF5osvG3j6r</span><br><span class="line">    (hex) 410d68b1bfd19d341bd0f772fad8697432d0d771be</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">Saving artifacts...</span><br><span class="line">Running migration: 2_deploy_contracts.js</span><br><span class="line">  Replacing TodoList...</span><br><span class="line">  TodoList:</span><br><span class="line">    (base58) TFyEw5qRRiZTJ5boLZJxZnv2hnhpBuvkjm</span><br><span class="line">    (hex) 4141d25df475fe0c053a9e2ed3a77faa10329185f0</span><br><span class="line">Saving successful migration to network...</span><br><span class="line">Saving artifacts...</span><br></pre></td></tr></table></figure><h4 id="3-3-修改配置参数"><a href="#3-3-修改配置参数" class="headerlink" title="3.3 修改配置参数"></a>3.3 修改配置参数</h4><p>打开文件, tron_boilerplate/src/tronweb.js, 代码如下: _<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">const fullNode = new HttpProvider(<span class="string">'http://127.0.0.1:8090'</span>);</span><br><span class="line">const solidityNode = new HttpProvider(<span class="string">'http://127.0.0.1:8091'</span>);</span><br><span class="line">const eventServer = <span class="string">'http://127.0.0.1:8092'</span>;</span><br><span class="line"></span><br><span class="line">const privateKey = <span class="string">"&lt;私钥地址&gt;"</span>;</span><br><span class="line">const contractAddr = <span class="string">"&lt;合约地址&gt;"</span>;</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><h4 id="3-4-启动react服务"><a href="#3-4-启动react服务" class="headerlink" title="3.4 启动react服务"></a>3.4 启动react服务</h4><p>执行<code>cmd+shift+p</code>，调用vscode的命令列表，选择run task从中选择<code>npm start</code>即可启动前端服务。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fz3883zfdlg30go091txz.gif" alt=""></p><p>打开浏览器，访问<a href="http://localhost:3000，" target="_blank" rel="noopener">http://localhost:3000，</a> 验证是否成功。</p><hr><p>到此，整个工程的搭建及开发流程就介绍完毕，如中间出现任何问题欢迎加我个人微信咨询。</p><h2 id="开发资料"><a href="#开发资料" class="headerlink" title="开发资料"></a>开发资料</h2><ul><li>波场官网：<a href="https://tron.network/index?lng=zh" target="_blank" rel="noopener">https://tron.network/index?lng=zh</a></li><li>波场区块链浏览器（主网）： <a href="https://tronscan.org/#/" target="_blank" rel="noopener">https://tronscan.org/#/</a></li><li>波场区块链浏览器 （测试网）<a href="https://test.tronscan.org/#/" target="_blank" rel="noopener">https://test.tronscan.org/#/</a></li><li>Documentation: <a href="https://github.com/tronprotocol/Documentation" target="_blank" rel="noopener">https://github.com/tronprotocol/Documentation</a></li><li>TRON开发者文档: <a href="https://developers.tron.network/" target="_blank" rel="noopener">https://developers.tron.network/</a></li><li>开发工具介绍: <a href="https://medium.com/tron-foundation/an-all-in-one-tool-suite-for-tron-developers-d048b2bc9b6c" target="_blank" rel="noopener">https://medium.com/tron-foundation/an-all-in-one-tool-suite-for-tron-developers-d048b2bc9b6c</a></li><li>TRON Chrome插件集成示例：<a href="https://github.com/tronpay/TronPay-Extension" target="_blank" rel="noopener">https://github.com/tronpay/TronPay-Extension</a></li><li>Tron-BIP44 implementation： <a href="https://www.npmjs.com/package/@faast/tron-payments" target="_blank" rel="noopener">https://www.npmjs.com/package/@faast/tron-payments</a></li><li>TRON开发项目模板(tron_boilerplate)：<a href="https://github.com/ChainDesk/tron_boilerplate" target="_blank" rel="noopener">https://github.com/ChainDesk/tron_boilerplate</a></li></ul><hr><blockquote><p>在教程中如出现不易理解或存在错误的问题，欢迎加我微信指正！<br>Name: zhangliang | WeChat: rushking2009 | Mail: <a href="mailto:zhangliang@cldy.org" target="_blank" rel="noopener">zhangliang@cldy.org</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      本教程通过以自己定制的工程模板为示例，讲解工程构建、快捷键部署私链及整体完整的开发注程，并配以操作动图帮助大家理解。hackdapp愿与你分享。 HackDApp愿与你分享！
    
    </summary>
    
      <category term="boilerplate" scheme="https://www.hackdapp.com/categories/boilerplate/"/>
    
    
      <category term="tron boilerplate" scheme="https://www.hackdapp.com/tags/tron-boilerplate/"/>
    
      <category term="波场开发指南" scheme="https://www.hackdapp.com/tags/%E6%B3%A2%E5%9C%BA%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>2019MetaLife</title>
    <link href="https://www.hackdapp.com/archives/2019metalife.html"/>
    <id>https://www.hackdapp.com/archives/2019metalife.html</id>
    <published>2019-01-07T16:28:42.000Z</published>
    <updated>2019-01-12T08:03:17.730Z</updated>
    
    <content type="html"><![CDATA[<p><strong>新年愿意清单</strong></p><ul><li>尝试每天500字，锻炼文字组织能力</li><li>做一款自己的小众产品，用户达到100人</li><li>尝试录制短视频</li><li>出版一本书籍</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;新年愿意清单&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尝试每天500字，锻炼文字组织能力&lt;/li&gt;
&lt;li&gt;做一款自己的小众产品，用户达到100人&lt;/li&gt;
&lt;li&gt;尝试录制短视频&lt;/li&gt;
&lt;li&gt;出版一本书籍&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="清单" scheme="https://www.hackdapp.com/categories/%E6%B8%85%E5%8D%95/"/>
    
    
  </entry>
  
</feed>
